#!/usr/bin/env bash

# Return arrays of dates between dates

help() {
    cat <<EOF
Usage: dateloop [OPTIONS] START [STOP]
Return array of dates ranging from START to STOP.

Boundaries dates are included.
Max dates looped over is 2000.

  -p, --plus     STOP is redefined as a new date: START +PLUS
                 Must consist of a number and a unit
  -f, --format   Date format. Default to '%Y%m%d'
  -h, --help     Display this help and exit

Examples:
  dateloop 20010101 20010105
  dateloop -p '4 days' 2001-01-01
  dateloop 20010101 2001-02-03 -f %Y-%m-%d

https://github.com/Descanonge/dateloop
EOF
}

help=0
plus="unset"
start="unset"
stop="unset"
format="%Y%m%d"
step="1 day"

if ! PARSED_ARGUMENTS=$(getopt -a -n dateloop -o hp:f: --long help,plus:,format: -- "$@"); then
    help
    exit 2
fi

eval set -- "$PARSED_ARGUMENTS"
while :
do
    case "$1" in
        -h | --help)  help=1       ; shift   ;;
        -p | --plus)  plus="$2"    ; shift 2 ;;
        -f | --format) format="$2" ; shift 2 ;;
        -s | --step) step="$2"     ; shift 2 ;;
        --) shift; break ;;
        *) echo "Unexpected option: $1"
           help; exit 2 ;;
    esac
done

if [[ "$help" == "1" ]]; then
    help
    exit 0
fi

if [[ "$1" == "" ]]; then
    echo "Need a starting date"
    help
    exit 1
fi
start="$(date -d "$1" "+$format")"

if [[ "$plus" != "unset" ]]; then
    stop="$(date -d "$start +$plus" "+$format")"
else
    if [[ "$2" == "" ]]; then
        echo "Need an ending date, or a plus value"
        help
        exit 1
    fi
    stop="$(date -d "$2" "+$format")"
fi

if [[ "$start" > "$stop" ]]; then
    echo "Ending date ($stop) is before starting date ($start)"
    exit 1
fi

dates=("$start")
counter=0
current="$start"
while [[ "$current" != "$stop" && counter -lt 2000 ]];
do
    counter=$((counter + 1))
    if ! current="$(date -d "$current +$step" "+$format")"; then
        break
    fi
    dates=("${dates[@]}" "$current")
done

echo "${dates[@]}"
