#!/usr/bin/env bash

# Return arrays of dates between dates

help() {
    cat <<EOF
Usage: dateloop [OPTIONS] START [STOP]
Return array of dates ranging from START to STOP.

Boundaries dates are included.
Max dates looped over is 2000.
Requires GNU date.

  -p, --plus      STOP is redefined as a new date: START +PLUS.
                  Must consist of a number and a unit.
  -f, --format    Date format. Default to '%Y%m%d'.
  -s, --step      Step between date. Default to '1 day'.
  -d, --delimiter Delimiter between dates in output.
                  Default to a single space.
  -h, --help      Display this help and exit

Examples:
  dateloop 20010101 20010105
  dateloop -p '4 days' 2001-01-01
  dateloop 20010101 2001-02-03 -f %Y-%m-%d
  dateloop "20010101 06:00" "20010102" -s '6 hours' \
      -f "%F %T" -d '\n'

https://github.com/Descanonge/dateloop
EOF
}

help=0
plus="unset"
start="unset"
stop="unset"
format="%Y%m%d"
step="1 day"
delimiter=" "

epoch="1970-01-01 UTC"

if ! PARSED_ARGUMENTS=$(getopt -a -n dateloop -o hp:f:s:d: \
    --long help,plus:,format:,step:,delimiter: -- "$@"); then
    help
    exit 2
fi

eval set -- "$PARSED_ARGUMENTS"
while :
do
    case "$1" in
        -h | --help)  help=1              ; shift   ;;
        -p | --plus)  plus="$2"           ; shift 2 ;;
        -f | --format) format="$2"        ; shift 2 ;;
        -s | --step) step="$2"            ; shift 2 ;;
        -d | --delimiter) delimiter="$2"  ; shift 2 ;;
        --) shift; break ;;
        *) echo "Unexpected option: $1"
           help; exit 2 ;;
    esac
done

if [[ "$help" == "1" ]]; then
    help
    exit 0
fi

if [[ "$1" == "" ]]; then
    echo "Need a starting date"
    help
    exit 1
fi
start="$(date -d "$1" "+%s")"

if [[ "$plus" != "unset" ]]; then
    stop="$(date -d "$epoch $start seconds +$plus" "+%s")"
else
    if [[ "$2" == "" ]]; then
        echo "Need an ending date, or a plus value"
        help
        exit 1
    fi
    stop="$(date -d "$2" "+%s")"
fi

if [[ "$start" > "$stop" ]]; then
    echo "Ending date ($stop) is before starting date ($start)"
    exit 1
fi

dates="$(date -d "$epoch $start seconds" "+$format")"
counter=0
current="$start"
while [[ "$current" -lt "$stop" && counter -lt 2000 ]];
do
    counter=$((counter + 1))
    if ! current="$(date -d "$epoch $current seconds +$step" "+%s")"; then
        break
    fi
    dates="${dates}${delimiter}$(date -d "$epoch $current seconds" "+$format")"
done

printf "%b" "$dates\n"
